<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<title>ShenYuanV's White Paper for Security</title>
<meta name="description" content="ShenYuanV's White Paper for Security">
<meta name="keywords" content="">

<meta property="og:type" content="article">
<meta property="og:title" content="How to exploit Write-what-where by using ret2usr &#8211; ">
<meta property="og:description" content="ShenYuanV's White Paper for Security">
<meta property="og:url" content="http://shenyuanv.github.io/2015/04/21/how_to_exploit_write_what_where_ret2usr.html">
<meta property="og:site_name" content="">

<!-- Webmaster Tools verfication -->




<link rel="canonical" href="http://shenyuanv.github.io/2015/04/21/how_to_exploit_write_what_where_ret2usr.html">
<link href="http://shenyuanv.github.io/feed.xml" type="application/atom+xml" rel="alternate" title=" Feed">

<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="http://shenyuanv.github.io/css/base.min.css" type="text/css" />
<link rel="stylesheet" href="http://shenyuanv.github.io/css/github.min.css" type="text/css" />
<link rel="stylesheet" href="http://shenyuanv.github.io/css/octicons.css" type="text/css" />
<link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>

</head>
<body>
  <div class="header-container">
  <header>
      <ul class="nav">
        <!--Change the  URL here if working on an absolute domain-->
        <li><a href="/"><span class="mega-octicon octicon-terminal" style="margin-right: 6px;"></span>White Paper</a></li>
        <li><a href="/about"><span class="mega-octicon octicon-person" style="margin-right: 6px;"></span>About</a></li>
      </ul>
  </header>
  <!--<script data-gratipay-username="vinitkme" data-gratipay-widget="button" src="//grtp.co/v1.js"></script>-->
</div>

  <div class="container">
    <p class="intro">
      ShenYuanV's White Paper.
    </p>
  <h2>How to exploit Write-what-where by using ret2usr</h2>
<p class="meta">21 Apr 2015</p>

<div class="post">
<h1 id="how-to-exploit-write-what-where-by-using-ret2usr---cve-2014-4322">How to exploit Write-what-where by using ret2usr - CVE-2014-4322</h1>

<h2 id="cve-2014-4322ret2usr">CVE-2014-4322&amp;ret2usr</h2>
<p>#漏洞成因
CVE-2014-4322是2014年12月底公布的Android高通驱动漏洞，漏洞的原因官方描述为：</p>

<p>“<strong>The qseecom driver provides an ioctl system call interface to user space clients for communication. When processing this communication, the __qseecom_update_cmd_buf function uses the user-supplied value cmd_buf_offset as an index to a buffer for write operations without any boundary checks, allowing a local application with access to the qseecom device node to, e.g., escalate privileges.</strong>”</p>

<p>简单来说就是ioctl调用时没有检查传入的参数就直接改变该指针指向的值，导致可以更改任意内存。
XDA论坛的“zxz0O0”将此漏洞利用后开发出了GIEFROOT提权工具，本篇文档将会从提权利用的角度来分析此漏洞。</p>

<h1 id="section">漏洞细节</h1>
<p><a href="https://us.codeaurora.org/cgit/quic/la/kernel/msm-3.10/tree/drivers/misc/qseecom.c?h=APSS.FSM4.1.0&amp;id=60db6b16517d6a8ab96d6760b8e1df7fe7ae1c71">漏洞代码</a></p>

<p>漏洞是处在ioctl接口中的
<strong>QSEECOM_IOCTL_SEND_MODFD_CMD_REQ</strong>部分，在这个分支中调用的<strong>qseecom_send_modfd_cmd</strong>函数没有对地址进行合法性检查直接对传入的指针进行赋值。</p>

<p><code class="highlighter-rouge">c
uint32_t *update;
update = (uint32_t *) field;
if (cleanup)
	*update = 0;
else
	*update = (uint32_t)sg_dma_address(sg_ptr-&gt;sgl);
len += (uint32_t)sg-&gt;length;
</code></p>

<p>简单说,这个漏洞能造成的后果就是:<strong>用户空间可以将任意地址(内核空间以及用户空间)的值设置为任意值</strong>.</p>

<h1 id="section-1">利用思路</h1>
<p>这是一个典型的任意地址写漏洞,这类漏洞的思路可以简化为:</p>

<blockquote>
  <p>寻找进程credential地址</p>
</blockquote>

<blockquote>
  <p>修改进程credential中自身的uid以及能力</p>
</blockquote>

<p>当然,这种方法最为直接,但有个问题需要解决:<strong>怎么确定credential的地址</strong>,一个进程的task_struct根据sp计算,而在开了ASLR的情况下无法定位到当前进程的内核sp,在不知道cred地址的情况下也无从下手.</p>

<p>有没有不需要在用户空间先获取内核sp的利用方法?</p>

<p>introducing <strong>RET2USR</strong>, 全称为return to user,顾名思义这种方法的思路就是讲内核执行的代码跳转到用户空间控制的地址从而执行任意代码.</p>

<h1 id="section-2">具体案例</h1>
<p><a href="https://github.com/retme7/CVE-2014-4322_poc">exploit by retme7</a></p>

<p>1、打开驱动、更改进程名
有漏洞的驱动位于/dev/qseecom，首先需要打开这个驱动文件对它进行操作，第一个值得注意的地方是exploit一开始就调用了prctl更改自己的进程名，这个举动的目的是让后面的程序更容易定位特定内存位置。</p>

<p><code class="highlighter-rouge">c
prctl(PR_SET_NAME, "ihoo.darkytools", 0, 0, 0);
</code></p>

<p>2、调用QSEECOM_IOCTL_SET_MEM_PARAM_REQ传入共享内存句柄以及shellcode内存地址</p>


</div>

<div class="keep-in-touch">
  <p>
    
  </p>
</div>
<a href="https://twitter.com/share" class="twitter-share-button" data-via="" data-size="large" data-hashtags="gotchacode">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>



  

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', '']);
  _gaq.push(['_trackPageview']);
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </div><!-- /.main -->
</body>
</html>